# PostgreSQL - Система управления базами данных (СУБД/DBMS)
# Это ряд программ и инмтрументов позволяющих создавать БД, управлть ею и манипулировать данными внутри (CRUD)

# Postgres - сама база данных, она объектно реляционная, то есть данные харняться в виде таблиц, и таюлиц имеют связи мужду собой

# SQL (Structured Query Language) - декларативный язык структурированных запросов, он применяется для создания и получения данных при помощи запросов в БД

# №-------------------------------------------------------------------------------------------------------------------------
# команда для входа в бд через юзура postgres:
# sudo -u postgres psql

# команда для входа
# exit

# команда для входа в своего юзура
# psql

# команда для выхода
# \q

# создание юзера
# CREATE ROLE 'bakberdi' SUPERUSER LOGIN PASSWORD '1';

# изменение пароля
# ALTER USER 'bakberdi' WITH PASSWORD '1';

# создание бд
# CREATE DATABASE 'bakberdi';

# \l - список все бд

# \du - все юзеры

# \dt - все таблицы (нужно подключится к бд заранее)

# \d 'name' - подробная информация про таблицу (нужно подключится к бд заранее)

# \c 'name' - команда для подключения к бд

# psql -U <username> -d <dbname> - подключаемся под выбранным username к dbname

# CREATE DATABASE - для удаления база данных 

#-------------------------------------------------------------------- 

# Типы полей в Postgres

# Numeric types(числовой типы)

    # a. smallint(2 bytes) -> -32767 to 32767
    # b. integer(4 bytes) -> -2.147...млн to 2.147...млн
    # c. bigint(8 bytes) -> ...(бесконечно)
    # d. real(4 bytes)  -> число с плавающей точка, вещественное число
    # f. double precsion (8 bytes) -> real но только с двойной точностью
    # d. sreial (4 bytes) -> integer, auto increment    

# Character types(Символы типа(строковые)):
    # a. varchar(количество символов) -> если мы кажем 50 символов, а заполним только 10, то остальные будут свободны. Макс символов 255
    # b. char(количество символов) -> если мы кажем 50 символов, а заполним только 10, то остальные будут заполнены пробелом. Макс символов 255
# 'john'
# 'john    '
    # c. text() -> неограниченная количество символов
# Boolen Type
    # a. boolean(1 bytes) -> True/False

#data -> календарная дата (год.месяц.день)

# location -> координатная точка (x,y) - (245, -12)

# enumerate types:
    # ('a', 'b', 'c')
    # CREATE TYPE <any name> AS ENUM('Happy', 'Sad', 'Mad');

#---------------------------------------------------------------------------------------------------
# Команда для созданий таблицы
# CREATE TABLE <tableNAME>(
    # <column><type>,
# )



# CREATE TABLE films (
# code char(5),
# title varchar(100),
# date date,
# ganre varchar(50),
# budget integer,
# country varchar(50),
# id serial
# );

# Команда для добавления данных в таблицу
# INSERT INTO <tablename> [(columns)]  VALUES (data),(data);

# films_db=# SELECT * FROM films;
#  code  |       title       |    date    |  ganre  | budget  | country | id 
# -------+-------------------+------------+---------+---------+---------+----
#  het5  | Lord of The Rings | 2001-06-12 | Fantasy | 1200000 | USA     |  1
#  AU56  | Game of Thrones   | 2015-05-31 | Fantasy | 1000000 | USE     |  2
# (2 rows)




#Команда для получение данных
# SELECT (colums)* FROM <table>;

# Команда для обнавление данных
# UPDATE <table> SET <column> = <new_value> WHERE <column> = <value>;


# Команда для удаление данных
# DELET FROM <table> WHERE <column> = <value>;

#-----------------------------------------------------------------------

# ORDER BY: Позволяет нам сортировать выводящие данные по убыванию или возрастанию. ASC(По возрастанию) и DESC(по убыванию)
#Синтаксиз:  SELECT<row> FROM <tablename> WHERE <row> = [ASC/DESC];

# WHERE: используется для фильтрации по полям. будут выводится только те данные которые соответсвуют условию оператора WHERE
#Синтаксиз:  SELECT<row> FROM <tablename> WHERE <row> = 'чему либо';

# BETWEEN: условие между
# SELECT * FROM products WHERE id BETWEEN 3 and 8

# LIKE: выводит результат который соответствует введенному шаблону для строк.
# Чувствителен к регистру
# ILIKE:тоже самое только не зависит от регистра
#Синтаксиз:  SELECT <row> FROM <tablename> WHERE <row> = LIKE/ILIKE 'чему либо';

# AND оператор и, для множественных условий
# IN: WHERE <row> in (1,2,3,4);

# LIMIT: ставит ограничения в кол-во получаемых данных

# GROUP BY: разделяет данные которые мы получили в SELECT, при этом группируя их по определенному признаку. И теперь для каждой группы можно использовать функцию

# Агригатныне функции: AVG(), COUNT(), MIN(), MAX(), SUM()

# HAVING: ставит условия при помощи которого данные отбираются в группировка

# Экспорт бд(дамп):
# pg_dump -U <username> -d 'dbname' > 'file.sql'

# Импорт:
# psql -U <username> -d <dbname> -f <filename>

#-----------------------------------------------------------------------------------------
# Свяи между таблицами(relation):
#   1. Один к одному (One to one) - человек и паспорт
        # в одну из таблиц добовляется поле fk и дается ограничение unique
#   2. Один ко многим (One to many) - Человек и банковские карты
        # в таблицу много (банковские карты)  доб. поле fk
#   3. Много ко многим (Many to many) - Студенты и преподы 
        # создается вспомогательная 3ья таблица со связями

# Ограничения: 
    # 1. NOT NUL - Обязательная к заполнению
    # 2. UNIQUE - То что будут хранится только уникальные данные
    # 3. CHECK -> CHECK age > 0 -ограничения проверки на условие 
    # 4. PRIMARY KAY (для устоновки связей между таблицами)
    # 5. FOREIGN KEY(ДЛЯ УСТОНОВКИ СВЯЗЕЙ МЕЖДУ ТАБЛИЦАМИ)
    # 6. ON DELETE -для устоновки поведения при удалении данных которые были связаны
#------------------------------------------------------------------------------------------

# JOIN: выборка данных из двух таблиц, соеденение таблиц

# LEFT JOIN: выборка будет содержать все строки из левой таблицы

# RIGHT JOIN: выборка будет содержать все строки из правой таблицы

# SELECT p1.title, p1.price, o1,quantity, p1.price * o1.quantity as
# total_sum FROM products p1, orders o1 WHERE p1.id = o1.product_id;
# - Запрос сразу две 

# SELECT p1.title, p1.price, o1.price, p1.price * o1.quantity as total_sum FROM products p1 JOIN order o1 ON p1 = o1.product_id;

